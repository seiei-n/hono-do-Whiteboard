<!DOCTYPE html>
<html lang="en">
    <body>
        <canvas
            id="canvas"
            width="500"
            height="500"
            style="border: 1px solid black"
        ></canvas>
        <button id="clear_button">Clear</button> <br />
        <script type="text/javascript">
            let currentWebSocket = null;
            const hostname = window.location.host;
            const protocol = window.location.protocol;
            const wsProtocol = protocol === "https:" ? "wss:" : "ws:";

            const outputDiv = document.getElementById("output_div");
            const sendButton = document.getElementById("send_button");
            const textInput = document.getElementById("text_input");

            const clearButton = document.getElementById("clear_button");
            const canvas = document.getElementById("canvas");
            const ctx = canvas.getContext("2d");
            const canvasWidth = 500;
            const canvasHeight = 500;
            var canvasData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
            var pixels = canvasData.data;
            var clickFlag = false;
            var canvasBgColor = "white";
            var canvasPenColor = "black";
            let counter = 0;

            function setCanvasBgColor(color) {
                canvasBgColor = color;
                canvas.style.backgroundColor = color;
            }

            function setCanvasPenColor(color) {
                canvasPenColor = color;
            }

            let lastXbuf;
            let lastYbuf;
            function drawFromServer(data) {
                counter++;
                console.log(counter);
                console.log(data);
                if (data.type === "end") {
                    lastXbuf = null;
                    lastYbuf = null;
                    return;
                }
                if (!lastXbuf || !lastYbuf) {
                    lastXbuf = data.x;
                    lastYbuf = data.y;
                    return;
                }
                const x = data.x;
                const y = data.y;
                const dx = Math.abs(x - lastXbuf);
                const dy = Math.abs(y - lastYbuf);
                const sx = lastXbuf < x ? 1 : -1;
                const sy = lastYbuf < y ? 1 : -1;
                let err = dx - dy;

                while (true) {
                    const index = (lastXbuf + lastYbuf * canvasWidth) * 4;
                    pixels[index + 0] = parseInt(
                        canvasPenColor.substring(1, 3),
                        16
                    );
                    pixels[index + 1] = parseInt(
                        canvasPenColor.substring(3, 5),
                        16
                    );
                    pixels[index + 2] = parseInt(
                        canvasPenColor.substring(5, 7),
                        16
                    );
                    pixels[index + 3] = 255;
                    if (lastXbuf === x && lastYbuf === y) {
                        break;
                    }
                    const e2 = 2 * err;
                    if (e2 > -dy) {
                        err -= dy;
                        lastXbuf += sx;
                    }
                    if (e2 < dx) {
                        err += dx;
                        lastYbuf += sy;
                    }
                }

                ctx.putImageData(canvasData, 0, 0);
            }

            function clearCanvas(data) {
                if (data.type !== "clear") {
                    return;
                }
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                canvasData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
                pixels = canvasData.data;
                ctx.putImageData(canvasData, 0, 0);
                setCanvasPenColor(canvasPenColor);
                setCanvasBgColor(canvasBgColor);
            }

            async function getDrawing() {
                const res = await fetch(
                    protocol + "//" + hostname + "/board/draw"
                );
                const data = await res.json();
                return data;
            }

            window.onload = async () => {
                const drawing = await getDrawing();
            };

            function join() {
                const ws = new WebSocket(
                    wsProtocol + "//" + hostname + "/board/websocket"
                );
                let rejoined = false;
                const startTime = Date.now();

                ws.addEventListener("open", (event) => {
                    currentWebSocket = ws;
                });

                ws.addEventListener("message", (event) => {
                    drawFromServer(JSON.parse(event.data));
                    clearCanvas(JSON.parse(event.data));
                });

                ws.addEventListener("close", (event) => {
                    console.log(
                        "WebSocket closed, reconnecting:",
                        event.code,
                        event.reason
                    );
                    rejoin();
                });

                ws.addEventListener("error", (event) => {
                    console.log("WebSocket  error, reconnecting:", event);
                    rejoin();
                });

                const rejoin = async () => {
                    if (!rejoined) {
                        rejoined = true;
                        currentWebSocket = null;

                        let timeSinceLastJoin = Date.now() - startTime;
                        if (timeSinceLastJoin < 5000) {
                            await new Promise((resolve) =>
                                setTimeout(resolve, 5000 - timeSinceLastJoin)
                            );
                        }

                        join();
                    }
                };
            }

            let lastX, lastY;
            function draw(e) {
                counter++;
                console.log(counter);
                if (!lastX || !lastY) {
                    lastX = e.offsetX;
                    lastY = e.offsetY;
                    return;
                }

                const x = e.offsetX;
                const y = e.offsetY;
                const dx = Math.abs(x - lastX);
                const dy = Math.abs(y - lastY);
                const sx = lastX < x ? 1 : -1;
                const sy = lastY < y ? 1 : -1;
                let err = dx - dy;

                while (true) {
                    const index = (lastX + lastY * canvasWidth) * 4;
                    pixels[index + 0] = parseInt(
                        canvasPenColor.substring(1, 3),
                        16
                    );
                    pixels[index + 1] = parseInt(
                        canvasPenColor.substring(3, 5),
                        16
                    );
                    pixels[index + 2] = parseInt(
                        canvasPenColor.substring(5, 7),
                        16
                    );
                    pixels[index + 3] = 255;
                    if (lastX === x && lastY === y) {
                        break;
                    }
                    const e2 = 2 * err;
                    if (e2 > -dy) {
                        err -= dy;
                        lastX += sx;
                    }
                    if (e2 < dx) {
                        err += dx;
                        lastY += sy;
                    }
                }

                ctx.putImageData(canvasData, 0, 0);
                const sendData = {
                    type: "draw",
                    x: lastX,
                    y: lastY,
                    color: canvasPenColor,
                };
                const canvasjson = JSON.stringify(sendData);
                currentWebSocket.send(canvasjson);
            }

            function draw2(e) {
                counter++;
                console.log(counter);

                const x = e.offsetX;
                const y = e.offsetY;

                if (!lastX || !lastY) {
                    lastX = x;
                    lastY = y;
                    return;
                }

                const startY = lastY;
                const startX = lastX;

                const controlPointX1 = startX + (x - startX) / 3;
                const controlPointY1 = startY;
                const controlPointX2 = startX + (2 * (x - startX)) / 3;
                const controlPointY2 = y;

                ctx.beginPath();
                ctx.moveTo(startX, startY);
                ctx.bezierCurveTo(
                    controlPointX1,
                    controlPointY1,
                    controlPointX2,
                    controlPointY2,
                    x,
                    y
                );

                // Set the line color and width
                ctx.strokeStyle = canvasPenColor;
                ctx.lineWidth = 2;

                // Draw the curve
                ctx.stroke();

                // Update lastX and lastY
                lastX = x;
                lastY = y;

                const sendData = {
                    type: "draw",
                    x: x,
                    y: y,
                    color: canvasPenColor,
                };
                const canvasjson = JSON.stringify(sendData);
                currentWebSocket.send(canvasjson);
            }

            function sendEnd(s) {
                const sendData = {
                    type: "end",
                };
                const canvasjson = JSON.stringify(sendData);
                currentWebSocket.send(canvasjson);
            }

            setCanvasBgColor(canvasBgColor);
            setCanvasPenColor(canvasPenColor);
            canvas.addEventListener("mousedown", function (e) {
                clickFlag = true;
                const s = "start";
                lastX = null;
                lastY = null;
                draw(e);
            });
            // for smartphone
            canvas.addEventListener("touchstart", function (e) {
                clickFlag = true;
                const s = "start";
                lastX = null;
                lastY = null;
                draw(e);
            });

            canvas.addEventListener("mousemove", function (e) {
                if (clickFlag) {
                    const s = "move";
                    // 300msごとにdrawを呼び出す
                    draw(e);
                    // setTimeout(draw1, 100, e);
                }
            });
            // for smartphone
            canvas.addEventListener("touchmove", function (e) {
                if (clickFlag) {
                    const s = "move";
                    // 300msごとにdrawを呼び出す
                    //draw1(e);
                    setTimeout(draw, 1000, e);
                }
            });

            canvas.addEventListener("mouseup", function (e) {
                clickFlag = false;
                const s = "end";
                lastX = null;
                lastY = null;
                sendEnd(s);
            });
            // for smartphone
            canvas.addEventListener("touchend", function (e) {
                clickFlag = false;
                const s = "end";
                lastX = null;
                lastY = null;
                sendEnd(s);
            });

            canvas.addEventListener("mouseout", function (e) {
                clickFlag = false;
                lastX = null;
                lastY = null;
                const s = "end";
                sendEnd(s);
            });
            // for smartphone
            canvas.addEventListener("touchcancel", function (e) {
                clickFlag = false;
                lastX = null;
                lastY = null;
                const s = "end";
                sendEnd(s);
            });

            clearButton.addEventListener("click", (event) => {
                ctx.clearRect(0, 0, canvasWidth, canvasHeight);
                canvasData = ctx.getImageData(0, 0, canvasWidth, canvasHeight);
                pixels = canvasData.data;
                ctx.putImageData(canvasData, 0, 0);
                const sendData = {
                    type: "clear",
                };
                const canvasjson = JSON.stringify(sendData);
                currentWebSocket.send(canvasjson);
                setCanvasPenColor(canvasPenColor);
                setCanvasBgColor(canvasBgColor);
            });

            join();
        </script>
    </body>
</html>
